# Insurance Hub System & Go Migration Analysis

## System Context

* [Diagram source PlantUML](/docs/c4-diagrams/context/insurance-hub-system-context-diagram.puml)
* [Generated diagram on www.plantuml.com](https://www.plantuml.com/plantuml/uml/ZPDFSzis4CNl_1HRdzoPsBhqr5CIHwdTsbEDfEIgWS2bY0f_sDsb77txOa69aLcbqni9BDxxOV7sFOiXwOElVdBH-hv6Q4Kw_dKs8_DwltFIzjkUaMoAWb7kRGgppfkeP-vOQk-siuTVxXQwzENbUHOC2r9UsZpeYMzotwbwnNiNEqCcW7SHvTWX998sLPKuyGYh8mi6E1s2sfcT5ZU9u2boJoPQXCT-MrKB94xnrkmopZku-RxxGLTkyj87K6983KYBuCO2DXuPkknhFBos2IoX4MGmiOPWOfRKRU-iGxw_-Rcg1ghRKMAJkt7fgKI3Ot2M4YCTd4M-snh66hYSrZiCwYxk2b7JUm_UDMYFrgDoZWQZ_JjeA0NukqzIZYNep35Wb09R9zkNdtnb92CknGlUpVoRtFx5X7hLJFVxQba-OJNmAN4kGOh6m-BJP_XjL85vp9YbOecnHc9uNByy3wP6J2QLf6T616tKfU_UD7kZBUcCRH7-qDzYU53UbH2Qe3VAYP4cKT2z1QM3g_KX822psI5iAUsHIkyC7wDjASNKCzWKGX-T7MYtAA-84SwDdx1iJTnl6iuE7_DNDZU2XJb_9iesQlxPZV6RFQo-3i_9mpxuT79I41UqYmglmi1dEMYo16l9-4WTfOp3kNQ298PSqmnGw_8DozxZ3ubUliwV_mD9ju4jkKuOf3K2DJOkOWPmLab9nISCTRAyESbbwK_dCFq0uQDFfv1tIEnOjFOQpJcDM6j2XYWVtmQbgfRepxCx7QilZ7g9oQ3AUKulnlJAm2ZXutgzM6KNzPY8Nup3AUt8_oA4NbziL9ejvwlrTRbpoXVzrZjkaGkSJP6p4cV5O5m4F1JLQOWlqd5T_NjkdqhaU1AujraZpBxMULSUOdoz9Phwklnb1hMAtwQbTDnustjjUceQf5A0_3-q9zdII9sQGoZay80yYSdO_L7zQVQdHkKznheF_Xy0)
* [Explanation of system context and flows](/docs/c4-diagrams/context/insurance-hub-system-context-analysis.md)

### Migration Notes

* None

## System Containers

* [Diagram source PlantUML](/docs/c4-diagrams/container/insurance-hub-container-diagram.puml)
* [Generated diagram on www.plantuml.com](https://www.plantuml.com/plantuml/uml/dLT1LoCv3hxdLsWvDFHx3RdiQKy30QPXcfriGZD7dk9I4WykkzPoGMVtxNzVo-KgAaN1qDnIjgNli_HPKdxXW3xKfPdyJLjbwe9W6qB5_vXEFJwTR7JOrgkQoIjd0zbmebmvhGnQiJdcK1Yzcix-VZoNfUyttwObSY0Vb-vdqGAr9NzIYVy9FsXReSSIJ5mDkuh0-R1raqdGmH1qvw7Gk95pQ-VXodBjqIg2h_KAbZiEL4ucXt2gWlCycPDdPuzmGpPyWOFdqwUoSX2NlZCnX2q19ri83fYC0TqThPpHIXC3sW8UDJt57sXsGIi-EVWycJIWzsUkjWNwtL5dUHzZqu5cYWUVuRyJ0813kFGfPWLyWbynq1FkqaPtpoEkC9h_GIkugoFZgXA-yUV9doo_ReMqjXj3nnLk2B2g8b4Csbcel7lKHTnCLvC4WOvWVesA8ka1qAQ1ZpvJM63kV43JiXAi6wqYMwp3FZ2G3Nu7bOlEKphG63YTNu6dVzV4WM7jNPauhFDj1Jq7OEOyGVBCv1-r8XxmYdZR-xmdvE8dB9jFuN6DZpZTO_OLRM68cmkBDTcGGvAoT_t7BGJtG1Os507Inijmf8JlUi3pjF0sz0rQt123ylICP_IQr4uP0hT-JL5klIRF8ooyAseL-ZIQbVVn25lg8sPJXG6DsuoXHKPsqqThLjv6cw5HjS503EA1M5Jm4fTXXKm5E0i5hIDW0Rusn6_47htQZgL0rj_cD4_Qb-X6CEjyYKR_Xuelq3Z5bQ7c6RjrpiGe4ToLPFV2twoyJu7DFRRE5A94fLnjGygtX4GHCp5aY17mmgawRVNWpzkrFe7VN33QxbFujP5sbbSfUkW87NkIR1NG8S0HdMnEli3y_98_Zp11tguS-gBFf5rxPnuO3N5NDDiwohNa9RsLaGZ4FFLZFukVxqJpXEOuw990VC2wjaem8bZO9NMcPi2H0KAihKkd7gZ9GLkNpZ4WB8Fpmu9qlchrMQmwJQRZ8czXiJW_krdAZyRyFIzTlEPdajqs7tj-RvpTkFEpdkUmVVjLPyzPOzbp-jZtF7SSDfwM__esfBqRw3OR1u-MCSLqz2xvwIR0_5m_mMcN_EOI5mPPFjD-3xZ_OA70W2bZcKvpMiWC9IKy_YTj_-9781zNyoJ0RNEEwqSFk7v0QICLgYt1R_APk3ocLnqyOIa5RsumHDHIzYvHQQD3yvfuPzNME-jg1kNAihPjRrbHU2Aoa0KhVFh8VxAdolaWmbqkqi--c5lIyWOXlrxdavp85kGPljx6qIc5GzlW0ELazuG7O06zNg_lrooTEls6XTJQf6ZSKBgMDfH3DBsvkzXBVIxxFjaWW-m3Aw-hCBpN2kr30tGMVqK032ICNiMQBUzwK68Et1b9gZkLvIePcGmm2wVudfFxVbLy3V7Ck5KFChTzAleHR5__8Ip8D0LfgokMXUzCCcC6yetYuTAufqayrewKN64U8bFrlxsTBwClEP1sdYUh6tmWJhEHGcCOWkiCfjVBt_y9dvwhaR0vRCSl2AuL2yFHybc33Ko7C1YMxj3eGdJR33mCJpfiXnmxunSZpyBLOjlDSS6zRfkBryUCX_t-vrraoNpCk9F01ysxzlWXyq6NctltGvCK5sifwIqRTyh8EasAFCwgW5c_5er8P9ZSbxFU8dDDMmGgJtNYJWRuPwKkBfQt1sDUnsHmIK5jYTiTA2YWDZpkKlwpzGjiKvNbkKcdRghrA6vRrkVrocWMlCEcCSyyoKi_119NcNK-_PhiPivoNRxJHzRTnwmxuNtKlbFUJzXF3hlUFwXrendjpJeBmgB9NEg_Jru7QgLzVNuso-HUY20llEsact0YAQcpZvJRCRTkXw7E2-_WDZzjVOodF7__fIEHgPJlxAqV_WzxsfzO6ZzoFZUpqHmDtsw_tNzp4JMlv0Ok5BgUU3NzFTCVKLzlIEdAWJJ9t3BVg0MZxWPzElTVkPodu3KzKd8_nd0yvS_3nbKfF8VpmwYdoIzaYxeq_mS0)
* [Explanation of system containers and flows](/docs/c4-diagrams/container/insurance-hub-container-analysis.md)

### Migration Notes

#### Internal systems
  
TODO

#### External systems
   
   | External system          | Java        | Go                |
   |--------------------------|-------------|-------------------|
   | Event streaming platform | Kafka       | Kafka             |
   | Bank statements storage  | File system | MinIO             |
   | Documents storage        | File system | MinIO             |
   | Tariff rules storage     | File system | Tarantool         |
   | PDF reports generator    | JSReports   | chromedp(library) |

<details>
<summary>Reasoning for using Tarantool for tariff rule scripts storage and execution</summary>

1. **Extreme Performance:** This is the most significant benefit. Tarantool is an in-memory database
   and application server. By rewriting the pricing rules in Lua and executing them as stored
   procedures, the calculations would occur at in-memory speeds, right next to the data. This will
   almost certainly be drastically faster than the current architecture's chain of
   `HTTP Request -> Service Logic -> File I/O -> Script Interpretation`.
2. **Superior Decoupling:** The pricing logic becomes a self-contained, language-agnostic component
   within Tarantool. The new component in Go becomes incredibly simple: its only job is to receive a request,
   call the appropriate Lua function in Tarantool with the necessary parameters, and return the
   result. We could update the pricing rules dynamically without ever redeploying the `pricing-service`.
3. **Centralized and Atomic Logic:** Managing business rules in a database is far more robust than
   managing script files. With Tarantool, we can update pricing rules transactionally, ensuring
   that the system is never in an inconsistent state. It creates a single source of truth for
   pricing.
4. **Future-Proofing:** By moving the logic into Tarantool, we make it accessible to _any_ service,
   regardless of the programming language. If we later add a new microservice in Python or Rust
   that needs to calculate a price, it can call the exact same Lua procedure in Tarantool that our
   Go service uses.

</details>

<details>
<summary>Reasoning for chromedp for generating PDF documents</summary>

1. **Architectural Simplification:** We eliminate the need for the external `JSReport` service. This
   means one less component to deploy, scale, monitor, and maintain, which reduces operational
   complexity and cost.
2. **High Fidelity Rendering:** Since we are using a real browser engine (Chrome's Blink), we get
   exceptionally high-quality rendering that supports modern HTML5, CSS3, and even JavaScript within
   the templates. Our existing templates are very likely to work with minimal to no changes.
3. **Self-Contained Service:** The `JSReport` service is replaced by a single, self-contained Go
   binary with no external runtime dependencies for PDF generation (though it does need access to a
   Chrome/Chromium executable on the same machine or in the same container).
4. **Performance:** We remove the network latency of the HTTP call to `JSReport`, which could lead
   to faster document generation.

</details>

#### External Exposure and Interservice Communication

Use gRPC for internal service communication while exposing select services via gRPC-gateway to
provide HTTP/OpenAPI functionality, combining the performance benefits of gRPC with the universal
compatibility of REST APIs.

<details>
<summary>Reasoning for using gRPC with gRPC-gateway</summary>

1. **Protocol Optimization**
   - **gRPC for internal communication**: provides superior performance, type safety, bidirectional
     streaming, and efficient binary serialization between your Go services
   - **HTTP/REST for external exposure**: ensures universal compatibility with web frontends, mobile
     apps, and third-party integrations

2. **Single API Definition** removes duplication and ensures consistency across protocols
   - Define APIs once in `.proto` files
   - Auto-generate GRPC server/client code
   - Auto-generate HTTP/JSON handlers
   - Auto-generate OpenAPI/Swagger documentation

3. **Performance Benefits**
   - Internal GRPC communication is ~7-10x faster than HTTP/JSON
   - Binary protocol reduces serialization overhead
   - HTTP/JSON translation only occurs at the edge where needed

4. **Typical Flow**

```
External Client (HTTP/JSON)
    └──> API Gateway (HTTP)
           └──> grpc-gateway (HTTP to gRPC)
                  └──> gRPC Service

Internal Microservices
    └──> Direct gRPC calls between each other
```

</details>


## System Container Components

TODO

### Migration Notes



## Phase 1: Architecture Understanding

### 1. **Study the Business Domain Model**
From the README, identify the core business entities:
- **Insurance Policies** - The main product being sold
- **Policy Accounts** - Financial tracking of policies
- **Payments** - Money transactions from customers
- **Products** - Insurance product catalog
- **Pricing/Tariffs** - Rule-based pricing system
- **Agents** - Sales personnel
- **Documents** - Policy documentation (PDFs)

### 2. **Map Bounded Contexts**
Based on the microservices structure, the bounded contexts are:
``` 
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   PRODUCT       │    │    PRICING      │    │    POLICY       │
│   CATALOG       │    │   MANAGEMENT    │    │   MANAGEMENT    │
│                 │    │                 │    │                 │
│ - Products      │    │ - Tariffs       │    │ - Offers        │
│ - Categories    │    │ - Rules (MVEL)  │    │ - Policies      │
│ - Questions     │    │ - Calculations  │    │ - CQRS Pattern  │
└─────────────────┘    └─────────────────┘    └─────────────────┘

┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│    PAYMENT      │    │   POLICY        │    │   DOCUMENT      │
│   MANAGEMENT    │    │    SEARCH       │    │  GENERATION     │
│                 │    │                 │    │                 │
│ - Accounts      │    │ - Search Index  │    │ - PDF Reports   │
│ - Payments      │    │ - ElasticSearch │    │ - Templates     │
│ - CSV Import    │    │ - Read Models   │    │ - JSReport      │
└─────────────────┘    └─────────────────┘    └─────────────────┘

┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│  DASHBOARD &    │    │      CHAT       │    │      AUTH       │
│   ANALYTICS     │    │   COMMUNICATION │    │ & AUTHORIZATION │
│                 │    │                 │    │                 │
│ - Sales Stats   │    │ - WebSockets    │    │ - JWT Tokens    │
│ - Agent Reports │    │ - Real-time     │    │ - User Roles    │
│ - Charts        │    │ - Messaging     │    │ - Security      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

## Phase 2: Communication Patterns Analysis

### 1. **Synchronous Communication (HTTP/REST)**
- → All services (API Gateway pattern) **agent-portal-gateway**
- → (price calculations) **policy-service** **pricing-service**
- **Frontend** → (single entry point) **agent-portal-gateway**

### 2. **Asynchronous Communication (Kafka Events)**
Key event flows:
``` 
policy-service → PolicyCreated Event → payment-service (creates account)
policy-service → PolicyCreated Event → policy-search-service (indexing)
policy-service → PolicyCreated Event → documents-service (PDF generation)
policy-service → PolicyCreated Event → dashboard-service (analytics)
payment-service → PaymentReceived Event → (other interested services)
```
### 3. **Real-time Communication (WebSockets)**
- ↔ **Frontend** (agent chat system) **chat-service**

## Phase 3: Data Flow & Integration Patterns

### 1. **CQRS Implementation**
demonstrates: **policy-service**
- **Command Side**: Create/update policies
- **Query Side**: Read policy data
- **Event Sourcing**: Policy state changes as events

### 2. **Event-Driven Architecture**
- **Event Publishing**: Services publish domain events
- **Event Consumption**: Services react to relevant events
- **Eventual Consistency**: Data sync across services

### 3. **API Gateway Pattern**
provides: **agent-portal-gateway**
- Single entry point for frontend
- Request routing to appropriate services
- Cross-cutting concerns (auth, logging, etc.)

## Phase 4: Technology Stack Mapping

### Current Java Stack → Go Equivalent

| Java/Micronaut | Go Alternative | Purpose |
| --- | --- | --- |
| Micronaut HTTP | Gin/Echo/Fiber | REST APIs |
| JPA/Hibernate | GORM | Database ORM |
| MongoDB Client | mongo-go-driver | NoSQL database |
| Kafka Client | Sarama/Confluent | Message streaming |
| ElasticSearch | go-elasticsearch | Search engine |
| JWT Security | golang-jwt | Authentication |
| WebSockets | gorilla/websocket | Real-time communication |
| Consul Client | consul/api | Service discovery |
| Zipkin | OpenTelemetry | Distributed tracing |
## Phase 5: Practical Analysis Steps
### 1. **Start with API Contracts**
Look for:
- REST endpoint definitions
- Event message schemas
- Database entity relationships

### 2. **Trace a Business Flow**
Follow this example flow:
``` 
1. Agent creates policy offer (policy-service)
2. System calculates price (pricing-service)
3. Offer converted to policy (policy-service)
4. PolicyCreated event published (Kafka)
5. Payment account created (payment-service)
6. Policy indexed for search (policy-search-service)
7. PDF document generated (documents-service)
8. Analytics updated (dashboard-service)
```
### 3. **Identify Integration Points**
- Database schemas and relationships
- Event message formats
- API request/response structures
- Configuration dependencies

## Recommended Tools for Analysis
1. **IDE/Editor**: Use IntelliJ to navigate the codebase
2. **Documentation**: Read the comprehensive blog post mentioned in README
3. **Docker Compose**: Run the system locally to see it in action
4. **API Documentation**: Check the Swagger/OpenAPI docs at `http://localhost:8081/swagger/`
5. **Observability**: Use Zipkin, Consul, and Kafka Manager dashboards

## Output Deliverables
Create these artifacts before coding:
1. **Service Dependency Diagram**: 
    - [Component C4 diagrams](/docs/c4-diagrams/component)
    - [System context C4 diagram](/docs/c4-diagrams/context)
    - [System container C4 diagram](/docs/c4-diagrams/container)
2. **Business Flows Documentation**: [Diagrams](/docs/business-flows) 
3. **API Contract Specifications**
4. **Database Schema Mapping**
5. **Go Project Structure Plan**
